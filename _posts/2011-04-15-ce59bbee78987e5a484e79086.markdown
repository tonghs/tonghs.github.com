---
author: ths
comments: true
date: 2011-04-15 00:56:00+00:00
layout: post
slug: c%e5%9b%be%e7%89%87%e5%a4%84%e7%90%86
title: C#图片处理
wordpress_id: 618
categories:
- 技术
tags:
- c
- 图片
- 图片处理
---

<





p>[http://liuyoubin1118611.blog.163.com/blog/static/74876904200910592637626/](http://liuyoubin1118611.blog.163.com/blog/static/74876904200910592637626/)





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215345192.jpg)





<





p>原始图片: ISINBAEVA ~~~~~~~~





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215243922.jpg)





<





p>一. 底片效果





<





p>原理: GetPixel方法获得每一点像素的值, 然后再使用SetPixel方法将取反后的颜色值设置到对应的点.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215252265.jpg)





<





p>代码实现:





<





p>底片效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以底片效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap newbitmap = new Bitmap(Width, Height);





<





p>Bitmap oldbitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel;





<





p>for (int x = 1; x < Width; x++)





<





p>{





<





p>for (int y = 1; y < Height; y++)





<





p>{





<





p>int r, g, b;





<





p>pixel = oldbitmap.GetPixel(x, y);





<





p>r = 255 - pixel.R;





<





p>g = 255 - pixel.G;





<





p>b = 255 - pixel.B;





<





p>newbitmap.SetPixel(x, y, Color.FromArgb(r, g, b));





<





p>}





<





p>}





<





p>this.pictureBox1.Image = newbitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示", MessageBoxButtons.OK, MessageBoxIcon.Information);





<





p>}





<





p>}





<





p>二. 浮雕效果





<





p>原理: 对图像像素点的像素值分别与相邻像素点的像素值相减后加上128, 然后将其作为新的像素点的值.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215261094.jpg)





<





p>代码实现:





<





p>浮雕效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以浮雕效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap newBitmap = new Bitmap(Width, Height);





<





p>Bitmap oldBitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel1, pixel2;





<





p>for (int x = 0; x < Width - 1; x++)





<





p>{





<





p>for (int y = 0; y < Height - 1; y++)





<





p>{





<





p>int r = 0, g = 0, b = 0;





<





p>pixel1 = oldBitmap.GetPixel(x, y);





<





p>pixel2 = oldBitmap.GetPixel(x + 1, y + 1);





<





p>r = Math.Abs(pixel1.R - pixel2.R + 128);





<





p>g = Math.Abs(pixel1.G - pixel2.G + 128);





<





p>b = Math.Abs(pixel1.B - pixel2.B + 128);





<





p>if (r > 255)





<





p>r = 255;





<





p>if (r < 0)





<





p>r = 0;





<





p>if (g > 255)





<





p>g = 255;





<





p>if (g < 0)





<





p>g = 0;





<





p>if (b > 255)





<





p>b = 255;





<





p>if (b < 0)





<





p>b = 0;





<





p>newBitmap.SetPixel(x, y, Color.FromArgb(r, g, b));





<





p>}





<





p>}





<





p>this.pictureBox1.Image = newBitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示", MessageBoxButtons.OK, MessageBoxIcon.Information);





<





p>}





<





p>}





<





p>三. 黑白效果





<





p>原理: 彩色图像处理成黑白效果通常有3种算法；





<





p>(1).最大值法: 使每个像素点的 R, G, B 值等于原像素点的 RGB (颜色值) 中最大的一个；





<





p>(2).平均值法: 使用每个像素点的 R,G,B值等于原像素点的RGB值的平均值；





<





p>(3).加权平均值法: 对每个像素点的 R, G, B值进行加权





<





p> ---自认为第三种方法做出来的黑白效果图像最 "真实".





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215265822.jpg)





<





p>代码实现:





<





p>黑白效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以黑白效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap newBitmap = new Bitmap(Width, Height);





<





p>Bitmap oldBitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel;





<





p>for (int x = 0; x < Width; x++)





<





p>for (int y = 0; y < Height; y++)





<





p>{





<





p>pixel = oldBitmap.GetPixel(x, y);





<





p>int r, g, b, Result = 0;





<





p>r = pixel.R;





<





p>g = pixel.G;





<





p>b = pixel.B;





<





p>//实例程序以加权平均值法产生黑白图像





<





p> int iType =2;





<





p>switch (iType)





<





p>{





<





p>case 0://平均值法





<





p> Result = ((r + g + b) / 3);





<





p>break;





<





p>case 1://最大值法





<





p> Result = r > g ? r : g;





<





p>Result = Result > b ? Result : b;





<





p>break;





<





p>case 2://加权平均值法





<





p> Result = ((int)(0.7 * r) + (int)(0.2 * g) + (int)(0.1 * b));





<





p>break;





<





p>}





<





p>newBitmap.SetPixel(x, y, Color.FromArgb(Result, Result, Result));





<





p>}





<





p>this.pictureBox1.Image = newBitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>四. 柔化效果





<





p>原理: 当前像素点与周围像素点的颜色差距较大时取其平均值.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215303920.jpg)





<





p>代码实现:





<





p>柔化效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以柔化效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap bitmap = new Bitmap(Width, Height);





<





p>Bitmap MyBitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel;





<





p>//高斯模板





<





p> int[] Gauss ={ 1, 2, 1, 2, 4, 2, 1, 2, 1 };





<





p>for (int x = 1; x < Width - 1; x++)





<





p>for (int y = 1; y < Height - 1; y++)





<





p>{





<





p>int r = 0, g = 0, b = 0;





<





p>int Index = 0;





<





p>for (int col = -1; col <= 1; col++)





<





p>for (int row = -1; row <= 1; row++)





<





p>{





<





p>pixel = MyBitmap.GetPixel(x + row, y + col);





<





p>r += pixel.R * Gauss[Index];





<





p>g += pixel.G * Gauss[Index];





<





p>b += pixel.B * Gauss[Index];





<





p>Index++;





<





p>}





<





p>r /= 16;





<





p>g /= 16;





<





p>b /= 16;





<





p>//处理颜色值溢出





<





p> r = r > 255 ? 255 : r;





<





p>r = r < 0 ? 0 : r;





<





p>g = g > 255 ? 255 : g;





<





p>g = g < 0 ? 0 : g;





<





p>b = b > 255 ? 255 : b;





<





p>b = b < 0 ? 0 : b;





<





p>bitmap.SetPixel(x - 1, y - 1, Color.FromArgb(r, g, b));





<





p>}





<





p>this.pictureBox1.Image = bitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>五.锐化效果





<





p>原理:突出显示颜色值大(即形成形体边缘)的像素点.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215325774.jpg)





<





p>实现代码:





<





p>锐化效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以锐化效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap newBitmap = new Bitmap(Width, Height);





<





p>Bitmap oldBitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel;





<





p>//拉普拉斯模板





<





p> int[] Laplacian ={ -1, -1, -1, -1, 9, -1, -1, -1, -1 };





<





p>for (int x = 1; x < Width - 1; x++)





<





p>for (int y = 1; y < Height - 1; y++)





<





p>{





<





p>int r = 0, g = 0, b = 0;





<





p>int Index = 0;





<





p>for (int col = -1; col <= 1; col++)





<





p>for (int row = -1; row <= 1; row++)





<





p>{





<





p>pixel = oldBitmap.GetPixel(x + row, y + col); r += pixel.R * Laplacian[Index];





<





p>g += pixel.G * Laplacian[Index];





<





p>b += pixel.B * Laplacian[Index];





<





p>Index++;





<





p>}





<





p>//处理颜色值溢出





<





p> r = r > 255 ? 255 : r;





<





p>r = r < 0 ? 0 : r;





<





p>g = g > 255 ? 255 : g;





<





p>g = g < 0 ? 0 : g;





<





p>b = b > 255 ? 255 : b;





<





p>b = b < 0 ? 0 : b;





<





p>newBitmap.SetPixel(x - 1, y - 1, Color.FromArgb(r, g, b));





<





p>}





<





p>this.pictureBox1.Image = newBitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>六. 雾化效果





<





p>原理: 在图像中引入一定的随机值, 打乱图像中的像素值





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215334826.jpg)





<





p>实现代码:





<





p>雾化效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以雾化效果显示图像





<





p> try





<





p>{





<





p>int Height = this.pictureBox1.Image.Height;





<





p>int Width = this.pictureBox1.Image.Width;





<





p>Bitmap newBitmap = new Bitmap(Width, Height);





<





p>Bitmap oldBitmap = (Bitmap)this.pictureBox1.Image;





<





p>Color pixel;





<





p>for (int x = 1; x < Width - 1; x++)





<





p>for (int y = 1; y < Height - 1; y++)





<





p>{





<





p>System.Random MyRandom = new Random();





<





p>int k = MyRandom.Next(123456);





<





p>//像素块大小





<





p> int dx = x + k % 19;





<





p>int dy = y + k % 19;





<





p>if (dx >= Width)





<





p>dx = Width - 1;





<





p>if (dy >= Height)





<





p>dy = Height - 1;





<





p>pixel = oldBitmap.GetPixel(dx, dy);





<





p>newBitmap.SetPixel(x, y, pixel);





<





p>}





<





p>this.pictureBox1.Image = newBitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>七. 光照效果





<





p>原理: 对图像中的某一范围内的像素的亮度分别进行处理.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215353731.jpg)





<





p>实现代码:





<





p>光照效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以光照效果显示图像





<





p> Graphics MyGraphics = this.pictureBox1.CreateGraphics();





<





p>MyGraphics.Clear(Color.White);





<





p>Bitmap MyBmp = new Bitmap(this.pictureBox1.Image, this.pictureBox1.Width, this.pictureBox1.Height);





<





p>int MyWidth = MyBmp.Width;





<





p>int MyHeight = MyBmp.Height;





<





p>Bitmap MyImage = MyBmp.Clone(new RectangleF(0, 0, MyWidth, MyHeight), System.Drawing.Imaging.PixelFormat.DontCare);





<





p>int A = Width / 2;





<





p>int B = Height / 2;





<





p>//MyCenter图片中心点，发亮此值会让强光中心发生偏移





<





p> Point MyCenter = new Point(MyWidth / 2, MyHeight / 2);





<





p>//R强光照射面的半径，即”光晕”





<





p> int R = Math.Min(MyWidth / 2, MyHeight / 2);





<





p>for (int i = MyWidth - 1; i >= 1; i--)





<





p>{





<





p>for (int j = MyHeight - 1; j >= 1; j--)





<





p>{





<





p>float MyLength = (float)Math.Sqrt(Math.Pow((i - MyCenter.X), 2) + Math.Pow((j - MyCenter.Y), 2));





<





p>//如果像素位于”光晕”之内





<





p> if (MyLength < R)





<





p>{





<





p>Color MyColor = MyImage.GetPixel(i, j);





<





p>int r, g, b;





<





p>//220亮度增加常量，该值越大，光亮度越强





<





p> float MyPixel = 220.0f * (1.0f - MyLength / R);





<





p>r = MyColor.R + (int)MyPixel;





<





p>r = Math.Max(0, Math.Min(r, 255));





<





p>g = MyColor.G + (int)MyPixel;





<





p>g = Math.Max(0, Math.Min(g, 255));





<





p>b = MyColor.B + (int)MyPixel;





<





p>b = Math.Max(0, Math.Min(b, 255));





<





p>//将增亮后的像素值回写到位图





<





p> Color MyNewColor = Color.FromArgb(255, r, g, b);





<





p>MyImage.SetPixel(i, j, MyNewColor);





<





p>}





<





p>}





<





p>//重新绘制图片





<





p> MyGraphics.DrawImage(MyImage, new Rectangle(0, 0, MyWidth, MyHeight));





<





p>}





<





p>}





<





p>}





<





p>八.百叶窗效果





<





p>原理:(1).垂直百叶窗效果:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215382994.jpg)





<





p>根据窗口或图像的高度或宽度和定制的百叶窗显示条宽度计算百叶窗显示的条数量 ；





<





p>根据窗口或图像的高度或宽度定制百叶窗显示条数量计算百窗显示的条宽度.





<





p>(2).水平百叶窗效果: 原理同上,只是绘制像素点开始的坐标不同.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215385562.jpg)





<





p>实现代码:





<





p>垂直百叶窗





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//垂直百叶窗显示图像





<





p> try





<





p>{





<





p>MyBitmap = (Bitmap)this.pictureBox1.Image.Clone();





<





p>int dw = MyBitmap.Width / 30;





<





p>int dh = MyBitmap.Height;





<





p>Graphics g = this.pictureBox1.CreateGraphics();





<





p>g.Clear(Color.Gray);





<





p>Point[] MyPoint = new Point[30];





<





p>for (int x = 0; x < 30; x++)





<





p>{





<





p>MyPoint[x].Y = 0;





<





p>MyPoint[x].X = x * dw;





<





p>}





<





p>Bitmap bitmap = new Bitmap(MyBitmap.Width, MyBitmap.Height);





<





p>for (int i = 0; i < dw; i++)





<





p>{





<





p>for (int j = 0; j < 30; j++)





<





p>{





<





p>for (int k = 0; k < dh; k++)





<





p>{





<





p>bitmap.SetPixel(MyPoint[j].X + i, MyPoint[j].Y + k,





<





p>MyBitmap.GetPixel(MyPoint[j].X + i, MyPoint[j].Y + k));





<





p>}





<





p>}





<





p>this.pictureBox1.Refresh();





<





p>this.pictureBox1.Image = bitmap;





<





p>System.Threading.Thread.Sleep(100);





<





p>}





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>水平百叶窗





<





p>private void button3_Click(object sender, EventArgs e)





<





p>{





<





p>//水平百叶窗显示图像





<





p> try





<





p>{





<





p>MyBitmap = (Bitmap)this.pictureBox1.Image.Clone();





<





p>int dh = MyBitmap.Height / 20;





<





p>int dw = MyBitmap.Width;





<





p>Graphics g = this.pictureBox1.CreateGraphics();





<





p>g.Clear(Color.Gray);





<





p>Point[] MyPoint = new Point[20];





<





p>for (int y = 0; y < 20; y++)





<





p>{





<





p>MyPoint[y].X = 0;





<





p>MyPoint[y].Y = y * dh;





<





p>}





<





p>Bitmap bitmap = new Bitmap(MyBitmap.Width, MyBitmap.Height);





<





p>for (int i = 0; i < dh; i++)





<





p>{





<





p>for (int j = 0; j < 20; j++)





<





p>{





<





p>for (int k = 0; k < dw; k++)





<





p>{





<





p>bitmap.SetPixel(MyPoint[j].X + k, MyPoint[j].Y + i, MyBitmap.GetPixel(MyPoint[j].X + k, MyPoint[j].Y + i));





<





p>}





<





p>}





<





p>this.pictureBox1.Refresh();





<





p>this.pictureBox1.Image = bitmap;





<





p>System.Threading.Thread.Sleep(100);





<





p>}





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>九.马赛克效果





<





p>原理: 确定图像的随机位置点和确定马赛克块的大小,然后马赛克块图像覆盖随机点即可.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215395137.jpg)





<





p>实现代码:





<





p>马赛克效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以马赛克效果显示图像





<





p> try





<





p>{





<





p>int dw = MyBitmap.Width / 50;





<





p>int dh = MyBitmap.Height / 50;





<





p>Graphics g = this.pictureBox1.CreateGraphics();





<





p>g.Clear(Color.Gray);





<





p>Point[] MyPoint = new Point[2500];





<





p>for (int x = 0; x < 50; x++)





<





p>for (int y = 0; y < 50; y++)





<





p>{





<





p>MyPoint[x * 50 + y].X = x * dw;





<





p>MyPoint[x * 50 + y].Y = y * dh;





<





p>}





<





p>Bitmap bitmap = new Bitmap(MyBitmap.Width, MyBitmap.Height);





<





p>for (int i = 0; i < 10000; i++)





<





p>{





<





p>System.Random MyRandom = new Random();





<





p>int iPos = MyRandom.Next(2500);





<





p>for (int m = 0; m < dw; m++)





<





p>for (int n = 0; n < dh; n++)





<





p>{





<





p>bitmap.SetPixel(MyPoint[iPos].X + m, MyPoint[iPos].Y + n, MyBitmap.GetPixel(MyPoint[iPos].X + m, MyPoint[iPos].Y + n));





<





p>}





<





p>this.pictureBox1.Refresh();





<





p>this.pictureBox1.Image = bitmap;





<





p>}





<





p>for (int i = 0; i < 2500; i++)





<





p>for (int m = 0; m < dw; m++)





<





p>for (int n = 0; n < dh; n++)





<





p>{





<





p>bitmap.SetPixel(MyPoint[i].X + m, MyPoint[i].Y + n, MyBitmap.GetPixel(MyPoint[i].X + m, MyPoint[i].Y + n));





<





p>}





<





p>this.pictureBox1.Refresh();





<





p>this.pictureBox1.Image = bitmap;





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>十. 油画效果





<





p>原理: 对图像中某一范围内的像素引入随机值.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215403227.jpg)





<





p>实现代码:





<





p>油画效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以油画效果显示图像





<





p> Graphics g = this.panel1.CreateGraphics();





<





p>//Bitmap bitmap = this.MyBitmap;





<





p>//取得图片尺寸





<





p> int width = MyBitmap.Width;





<





p>int height = MyBitmap.Height;





<





p>RectangleF rect = new RectangleF(0, 0, width, height);





<





p>Bitmap img = MyBitmap.Clone(rect, System.Drawing.Imaging.PixelFormat.DontCare);





<





p>//产生随机数序列





<





p> Random rnd = new Random();





<





p>//取不同的值决定油画效果的不同程度





<





p> int iModel = 2;





<





p>int i = width - iModel;





<





p>while (i > 1)





<





p>{





<





p>int j = height - iModel;





<





p>while (j > 1)





<





p>{





<





p>int iPos = rnd.Next(100000) % iModel;





<





p>//将该点的RGB值设置成附近iModel点之内的任一点





<





p> Color color = img.GetPixel(i + iPos, j + iPos);





<





p>img.SetPixel(i, j, color);





<





p>j = j - 1;





<





p>}





<





p>i = i - 1;





<





p>}





<





p>//重新绘制图像





<





p> g.Clear(Color.White);





<





p>g.DrawImage(img, new Rectangle(0, 0, width, height));





<





p>}





<





p>十一: 扭曲效果





<





p>原理: 将图像缩放为一个非矩形的平等四边形即可





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215412766.jpg)





<





p>实现代码:





<





p>扭曲效果





<





p> private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以扭曲效果显示图像





<





p> if (h == panel1.Height/2)





<





p>{





<





p>w = 0;





<





p>h = 0;





<





p>}





<





p>Size offset =new Size (w++,h++);//设置偏移量





<





p> Graphics g = panel1.CreateGraphics();





<





p>Rectangle rect = this.panel1.ClientRectangle;





<





p>Point[] points = new Point[3];





<





p>points[0] = new Point(rect.Left+offset.Width ,rect.Top +offset .Height);





<





p>points[1] = new Point(rect.Right, rect.Top + offset.Height);





<





p>points[2] = new Point(rect.Left, rect.Bottom - offset.Height);





<





p>g.Clear(Color.White);





<





p>g.DrawImage(MyBitmap, points);





<





p>}





<





p>十二.积木效果





<





p>原理: 对图像中的各个像素点着重(即加大分像素的颜色值)着色.





<





p>效果图:





<





p>![C图片处理（转） - 刘友斌 - 青春无悔](http://pic002.cnblogs.com/img/.%20%e5%b0%90%e5%84%8d%e8%8b%bd/200903/2009030215420550.jpg)





<





p>实现代码:





<





p>积木效果





<





p>private void button1_Click(object sender, EventArgs e)





<





p>{





<





p>//以积木效果显示图像





<





p> try





<





p>{





<





p>Graphics myGraphics = this.panel1.CreateGraphics ();





<





p>//Bitmap myBitmap = new Bitmap(this.BackgroundImage);





<





p> int myWidth, myHeight, i, j, iAvg, iPixel;





<





p>Color myColor, myNewColor;





<





p>RectangleF myRect;





<





p>myWidth = MyBitmap.Width;





<





p>myHeight = MyBitmap.Height;





<





p>myRect = new RectangleF(0, 0, myWidth, myHeight);





<





p>Bitmap bitmap = MyBitmap.Clone(myRect, System.Drawing.Imaging.PixelFormat.DontCare);





<





p>i = 0;





<





p>while (i < myWidth - 1)





<





p>{





<





p>j = 0;





<





p>while (j < myHeight - 1)





<





p>{





<





p>myColor = bitmap.GetPixel(i, j);





<





p>iAvg = (myColor.R + myColor.G + myColor.B) / 3;





<





p>iPixel = 0;





<





p>if (iAvg >= 128)





<





p>iPixel = 255;





<





p>else





<





p>iPixel = 0;





<





p>myNewColor = Color.FromArgb(255, iPixel, iPixel, iPixel);





<





p>bitmap.SetPixel(i, j, myNewColor);





<





p>j = j + 1;





<





p>}





<





p>i = i + 1;





<





p>}





<





p>myGraphics.Clear(Color.WhiteSmoke);





<





p>myGraphics.DrawImage(bitmap, new Rectangle(0, 0, myWidth, myHeight));





<





p>}





<





p>catch (Exception ex)





<





p>{





<





p>MessageBox.Show(ex.Message, "信息提示");





<





p>}





<





p>}





<





p>说明.这些大多为静态图. 后面会有图像的动态显示. 如分块合成图像, 四周扩散显示图像, 上下对接显示图像等.





<





p> 这些也许能说明一下 PPT或者手机中的图片效果处理程序是如果做出来的.原理应该是相通的.





<





p> 制作图像一般常用的类有: Bitmap; Graphics; Rectangle；Color; 用到的方法是 Graphics类的DrawImage；





<





p> 此方法共有30个版本, 我习惯用 DrawImage("图像", "图框") 版本.





<





p> 因为这个版本的思想是最简单的----把一张**地图像装在一个**地框里! (**代表某种效果的图像和某种效果的框)





<





p> 如. g.DrawImage(new Bitmap("myPicture"), new Rectangle(0, 0, myWidth, myHeight));



