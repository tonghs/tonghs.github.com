---
author: ths
comments: true
date: 2011-03-21 09:01:00+00:00
layout: post
slug: inno-setup%e6%93%8d%e4%bd%9c%e6%b3%a8%e5%86%8c%e8%a1%a8
title: inno setup操作注册表
wordpress_id: 574
categories:
- 技术
- 折腾
tags:
- inno setup
- 注册表
---

<





p>[Registry] 段





<





p>这个可选段用来定义一些你想用安装程序在用户系统中创建、修改或删除的注册表键/值。   
按默认，用安装程序创建的注册表键和值在卸载时不删除。如果你想让卸载程序删除键或值，你必须包含下面 uninsdelete* 标记中的一个。  
下面是 [Registry] 段的一个示例。





<





p>[Registry]   
Root: HKCU; Subkey: "SoftwareMy Company"; Flags: uninsdeletekeyifempty   
Root: HKCU; Subkey: "SoftwareMy CompanyMy Program"; Flags: uninsdeletekey   
Root: HKLM; Subkey: "SoftwareMy Company"; Flags: uninsdeletekeyifempty   
Root: HKLM; Subkey: "SoftwareMy CompanyMy Program"; Flags: uninsdeletekey   
Root: HKLM; Subkey: "SoftwareMy CompanyMy Program"; ValueType: string; ValueName: "InstallPath"; ValueData: "{app}"





<





p>下列是所支持的参数列表:





<





p>Root (必需)   
描述:   
根键。必须是下列值中的一个:   
HKCR (HKEY_CLASSES_ROOT)   
HKCU (HKEY_CURRENT_USER)   
HKLM (HKEY_LOCAL_MACHINE)   
HKU (HKEY_USERS)   
HKCC (HKEY_CURRENT_CONFIG)   
该值可以带有 32 或 64 的后缀。带 32 后缀的根键值 (例如 HKLM32) 映射到 32 位系统注册表，带 64 后缀的根键值 (例如 HKLM32) 映射到 64 位系统注册表。   
带 64 后缀的根键值只能在安装程序在 64 位 Windows 运行时使用，否则将会出错。在支持 32 和 64 位结构的安装程序中，这可以通过添加下列 IsWin64 参数检查来避免，这会在运行于 32 位 Windows 时该条目自动跳过。





<





p>不带后缀的根键值 (例如 HKLM) 等于带后缀 32 的值 (例如 HKLM32)，除非安装程序运行于 64 位模式，在这种情况下，该值等于带后缀 64 的值 (例如 HKLM64)。  
示例:   
Root: HKCU





<





p>Subkey (必需)   
描述:   
子键名，可以包含常量。   
示例:   
Subkey: "SoftwareMy CompanyMy Program"





<





p>ValueType   
描述:   
值的数据类型。必须是下面中的一个:   
none   
string   
expandsz   
multisz   
dword   
binary





<





p>如果指定了 none （默认设置），安装程序将创建一个没有键值的键，在这种情况下，ValueName 和 ValueData 参数将被忽略。





<





p>如果指定了 string，安装程序将创建一个字符串 （REG_SZ） 值。





<





p>如果指定了 expandsz，安装程序将创建一个扩展字符串 （REG_EXPAND_SZ） 值。这种数据类型起初是用于 Windows NT/2000/XP/2003 上，但是也支持 Windows 95/98/me。





<





p>如果指定了 multisz，安装程序将创建一个多行文本 （REG_MULTI_SZ） 值。





<





p>如果指定了 dword，安装程序将创建一个整数 （REG_DWORD） 值。





<





p>如果指定了 binary，安装程序将创建一个二进制 （REG_BINARY） 值。





<





p>示例:   
ValueType: string





<





p>ValueName   
描述:   
要创建的值名，可以包含常量。如果是空白的，将写入到“默认”值。如果 ValueType 参数设置为 none，这个参数被忽略。   
示例:   
ValueName: "Version"





<





p>ValueData   
描述:   
值的数据。如果 ValueType 参数是 string，expandsz 或 ultisz，这是这一个可以包含常量的字符串。如果数据类型是 dword，这可以是一个十进制整数 (例如“123”)，一个十六进制整数 (例如“$7B”) 或解析为整数的常量。如果数据类型是 binary，这可以是下列形式的十六进制字节序列: “00 ff 12 34”。如果数据类型是 none，将被忽略。





<





p>在 string，expandsz 或 multisz 类型值中，你可以在这个参数中使用一个特殊的常量调用 {olddata}。{olddata} 用先前的注册表值数据替换。如果你想添加一个字串到现有的值中，{olddata} 常量非常有用。例如，{olddata};{app}。如果该值不存在或现有的值不是一个字符串类型，{olddata} 常量将被删除。如果创建的值是一个 multisz 类型，但现有的值不是多行字符类型(例如，它是 REG_SZ 或 REG_EXPAND_SZ)，{olddata} 常量也将被删除。反这亦然。





<





p>在 multisz 类型值中，你可以在参数中使用一个特殊常量调用 {break} 以插入换行符。  
示例:   
ValueData: "1.0"





<





p>Permissions   
描述:





<





p>指定登录注册表键 ACL (访问控制列表) 的附加权限。如果你不熟悉 ACL 或你不知道为什么要列改，不推荐你使用这个参数，因为误用会导致重大的系统安全问题。





<





p>这个参数在用户必须运行 Windows 2000 或更高版本 (NT 4.0 由于 API 的问题不支持) 以及当前用户必须有更改注册表的权限时才有效。这些条件不满足时，不会显示错误消息，权限也不会被设置。





<





p>这个参数应该只使用于你的应用程序特有的注册表键中。不要更改顶级键象 HKEY_LOCAL_MACHINESOFTWARE 的 ACL，否则你自己打开了用户系统的安全漏洞。





<





p>指定的权限不考虑注册表键在安装前是否存在。如果 ValueType 是 none 和使用了 deletekey 或 deletevalue 标记时，不要设置这个权限。





<





p>这个参数可以包含象下列格式一样一个或多个空格分隔的值:





<





p><用户或组标识>-<访问类型>





<





p>下面是 [Registry] 段支持的访问类型:





<





p>full





<





p>同意“完全控制”许可，与修改相同 (看下面)，但又加上允许指定的用户/用户组获取注册表键所有权，并改变它的许可。通常保守的使用 modify 就足够了。





<





p>modify





<





p>同意“修改”许可，允许指定的用户/用户组读取、修改和删除注册表值或子键。





<





p>read





<





p>同意“读取和执行”许可，允许指定的用户/用户组读取注册表值或子键。





<





p>示例:   
Permissions: authusers-modify





<





p>Flags   
描述:





<





p>这个参数是额外选项设置。多个选项可以使用空格隔开。支持下面的选项:





<





p>createvalueifdoesntexist





<





p>当指定了这个标记，安装程序只在如果没有相同名字的值存在时创建值。如果值类型是 none，或如果你指定了 deletevalue 标记，这个标记无效。





<





p>deletekey





<





p>当指定了这个标记，安装程序在如果条目存在的情况下，先将尝试删除它，包括其中的所有值和子键。如果 ValueType 不是 none，那么它将创建一个新的键和值。





<





p>要防止意外，如果子键是空白的或只包含反斜框符号，安装时这个标记被忽略。





<





p>deletevalue





<





p>当指定了这个标记，安装程序在如果值存在的情况下，先将尝试删除值，如果 ValueType 是 none，那么在键不存在的情况下，它将创建键以及新值。





<





p>dontcreatekey





<





p>当指定了这个标记，如果键已经在用户系统中不存在，安装程序将不尝试创建键或值。如果键不存在，不显示错误消息。





<





p>一般来说，这个键与 uninsdeletekey 标记组合使用，在卸载时删除键，但安装时不创建键。





<





p>noerror





<





p>如果安装程序因任何原因创建键或值失败，不显示错误消息。





<





p>preservestringtype





<





p>这只在当 ValueType 参数是 string 或 expandsz 时适用。当指定这个标记，并且值不存在或现有的值不是 string 类型 (REG_SZ 或 REG_EXPAND_SZ)，它将用 ValueType 指定的类型创建。如果值存在，并且是 string 类型，它将用先存在值的相同值类型替换。





<





p>uninsclearvalue





<





p>当卸载程序时，设置值数据为空字符 (类型 REG_SZ)。这个标记不能与 uninsdeletekey 标记组合使用。





<





p>uninsdeletekey





<





p>当卸载程序时，删除整个键，包含其中的所有值和子键。这对于 Windows 自身使用的键明显不是一个好方法。你只能用于你的应用程序特有的键中。





<





p>为防止意外，安装期间如果子键空白或只包含反斜框符号，这个标记被忽略。





<





p>uninsdeletekeyifempty





<





p>当程序卸载时，如果这个键的内部没有值或子键，则删除这个键。这个标记可以与 uninsdeletevalue 组合使用。





<





p>为防止意外，安装期间如果子键空白或只包含反斜框符号，这个标记被忽略。





<





p>uninsdeletevalue





<





p>当程序卸载时删除该值。这个标记不能与 uninsdeletekeyifempty 组合使用。





<





p>注意: 在早于 1.1 的 Inno Setup 版本中，你可以使用这个标记连同数据类型 none，那么它的功能与“如果空则删除键”标记一样。这个方法已经不支持了。你必须使用 uninsdeletekeyifempty 标记实现。





示例:   
Flags: uninsdeletevalue 



